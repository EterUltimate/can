/*# AI åŠ©æ‰‹ - å¤©æ°”æŸ¥è¯¢ä¸å¯¹è¯ç³»ç»Ÿ

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªæ”¯æŒè‡ªå®šä¹‰ API åœ°å€ã€å¤šæ¨¡å‹é€‰æ‹©ã€æµå¼å“åº”ä¸ Token è´¹ç”¨ç»Ÿè®¡çš„ Web èŠå¤©ç•Œé¢ï¼Œä½œä¸ºè¯¾ç¨‹ä½œä¸šå¼€å‘å®Œæˆã€‚

---

## ğŸ“œ å¼€æºè®¸å¯

æœ¬é¡¹ç›®ä»£ç é‡‡ç”¨ **MIT License** å¼€æºï¼ˆè¯¦è§ [`LICENSE`](LICENSE) æ–‡ä»¶ï¼‰ã€‚  
ä½ å¯ä»¥è‡ªç”±åœ°ï¼š

- âœ… é˜…è¯»ã€å­¦ä¹ ã€å‚è€ƒå®ç°æ€è·¯ï¼›
- âœ… åœ¨ä¸ªäººé¡¹ç›®æˆ–éå­¦æœ¯åœºæ™¯ä¸­ä½¿ç”¨ï¼›
- âœ… ä¿®æ”¹å¹¶ç”¨äºå¼€æºè´¡çŒ®ï¼ˆéœ€ä¿ç•™åŸä½œè€…ç‰ˆæƒå£°æ˜ï¼‰ã€‚

---

## ğŸš« å­¦æœ¯è¯šä¿¡ç‰¹åˆ«å£°æ˜

> âš ï¸ **æœ¬é¡¹ç›®ä¸ºåŸåˆ›è¯¾ç¨‹ä½œä¸šï¼Œä¸¥ç¦ä»»ä½•å½¢å¼çš„å­¦æœ¯ä¸ç«¯è¡Œä¸ºï¼**

**æ˜ç¡®ç¦æ­¢ä»¥ä¸‹ç”¨é€”**ï¼š
- å°†æœ¬é¡¹ç›®çš„å…¨éƒ¨æˆ–éƒ¨åˆ†ä»£ç ç›´æ¥æäº¤ä¸ºè‡ªå·±çš„è¯¾ç¨‹ä½œä¸šã€å®éªŒæŠ¥å‘Šæˆ–æ¯•ä¸šè®¾è®¡ï¼›
- ä»…ä¿®æ”¹å˜é‡åã€æ³¨é‡Šæˆ–å°‘é‡é€»è¾‘åå£°ç§°æ˜¯è‡ªå·±ç‹¬ç«‹å®Œæˆçš„ä½œå“ï¼›
- åœ¨æœªæ˜ç¡®å¼•ç”¨ã€æœªè·å¾—æˆæƒçš„æƒ…å†µä¸‹ï¼Œå°†æœ¬é¡¹ç›®ç”¨äºä»»ä½•éœ€è¦â€œåŸåˆ›æ€§â€è¯„ä¼°çš„å­¦æœ¯åœºæ™¯ã€‚

**å…è®¸çš„åˆç†ä½¿ç”¨**ï¼š
- ä½œä¸ºæŠ€æœ¯å‚è€ƒï¼Œç†è§£å‰ç«¯äº¤äº’ã€API é›†æˆã€æµå¼å“åº”ç­‰å®ç°æ–¹å¼ï¼›
- åœ¨éå­¦æœ¯é¡¹ç›®ï¼ˆå¦‚ä¸ªäººåšå®¢ã€å¼€æºå·¥å…·ï¼‰ä¸­å¤ç”¨éƒ¨åˆ†ä»£ç ï¼ˆéµå®ˆ MIT è¦æ±‚ï¼‰ï¼›
- å¼•ç”¨æœ¬é¡¹ç›®æ—¶ï¼Œè¯·æ³¨æ˜åŸå§‹ä½œè€…ä¸é¡¹ç›®é“¾æ¥ã€‚

> ğŸ“Œ **é‡è¦æé†’**ï¼š  
> å¼€æº â‰  æ”¾å¼ƒè‘—ä½œæƒ â‰  å…è®¸æŠ„è¢­ã€‚  
> æ ¹æ®ã€Šé«˜ç­‰å­¦æ ¡ç§‘å­¦æŠ€æœ¯å­¦æœ¯è§„èŒƒæŒ‡å—ã€‹åŠå¤šæ•°é«˜æ ¡è§„å®šï¼Œ**æœªç»å£°æ˜ç›´æ¥ä½¿ç”¨ä»–äººå¼€æºä»£ç ä½œä¸ºä¸ªäººä½œä¸šæˆæœï¼Œå±äºå­¦æœ¯ä¸ç«¯è¡Œä¸º**ã€‚

---

## ğŸ™ è‡´è°¢ä¸äº¤æµ

æ¬¢è¿æå‡º Issue æˆ– PR è¿›è¡ŒæŠ€æœ¯è®¨è®ºï¼  
ä½†è¯·å‹¿è¯·æ±‚â€œå¸®æˆ‘æ”¹æˆå¦ä¸€ä¸ªä½œä¸šâ€æˆ–â€œå»æ‰ä½œè€…ä¿¡æ¯â€â€”â€”è¿™è¿èƒŒæœ¬é¡¹ç›®å¼€æºåˆè¡·ã€‚

ä½œè€…ï¼š[EterUltimate]  
é‚®ç®±ï¼š1831303476@qq.com
å­¦æ ¡ï¼š[zjnu]
*/
// ========== å…¨å±€é…ç½® ==========
let settings = {
  apiKey: '',
  model: '',
  apiBaseUrl: 'https://api.gemai.cc' // é»˜è®¤APIåŸºç¡€åœ°å€
};

let totalInputTokens = 0;
let totalOutputTokens = 0;

// ========== å·¥å…·å‡½æ•° ==========
function getFullUrl(endpoint) {
  const base = settings.apiBaseUrl.endsWith('/') ? settings.apiBaseUrl.slice(0, -1) : settings.apiBaseUrl;
  return `${base}${endpoint.startsWith('/') ? endpoint : '/' + endpoint}`;
}

// ========== ä¸»é¢˜åˆ‡æ¢ ==========
document.addEventListener('DOMContentLoaded', () => {
  const themeToggle = document.getElementById('themeToggle');
  const body = document.body;

  const savedTheme = localStorage.getItem('theme') || 'light';
  if (savedTheme === 'dark') body.classList.add('dark-theme');

  themeToggle.addEventListener('click', () => {
    body.classList.toggle('dark-theme');
    localStorage.setItem('theme', body.classList.contains('dark-theme') ? 'dark' : 'light');
  });
});

// ========== æ—¶é—´æ˜¾ç¤º ==========
function updateTime() {
  const now = new Date();
  const timeString = now.toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    weekday: 'long'
  });
  document.getElementById('timeData').textContent = timeString;
}

// ========== å¤©æ°”åŠŸèƒ½ ==========
async function fetchWeather(city) {
  const weatherElement = document.getElementById('weatherData');
  const cleanCity = encodeURIComponent(city.trim());
  if (!cleanCity) {
    weatherElement.textContent = 'è¯·è¾“å…¥åŸå¸‚å';
    return;
  }
  weatherElement.textContent = 'è·å–å¤©æ°”ä¸­...';
  try {
    const url = `https://wttr.in/${cleanCity}?format=j1`;
    const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    const current = data.current_condition[0];
    weatherElement.innerHTML = `${current.weatherDesc[0].value}ï¼Œ${current.temp_C}Â°Cï¼ˆä½“æ„Ÿ ${current.FeelsLikeC}Â°Cï¼‰<br>ğŸ’§ æ¹¿åº¦: ${current.humidity}%`;
  } catch (error) {
    weatherElement.textContent = `âŒ æ— æ³•è·å– "${city}" çš„å¤©æ°”`;
  }
}

// ========== æ¨¡å‹å…ƒæ•°æ® ==========
const MODEL_METADATA = {
  "gpt-4o": { desc: "OpenAI æœ€å¼ºå¤šæ¨¡æ€æ¨¡å‹", price: { input: 5, output: 15 } },
  "gpt-4o-mini": { desc: "GPT-4o è½»é‡ç‰ˆï¼Œæ€§ä»·æ¯”é«˜", price: { input: 0.15, output: 0.6 } },
  "qwen-max": { desc: "é€šä¹‰åƒé—®æœ€å¼ºç‰ˆæœ¬", price: { input: 2, output: 6 } },
  "claude-3-5-sonnet": { desc: "Anthropic æ™ºèƒ½æ¨¡å‹", price: { input: 3, output: 15 } }
};

function updateModelDescription(modelId) {
  const descEl = document.getElementById('modelDesc');
  const meta = MODEL_METADATA[modelId];
  if (meta) {
    descEl.innerHTML = `${meta.desc}<br>ğŸ’° ä»·æ ¼ï¼šè¾“å…¥ $${meta.price.input}/1M tokensï¼Œè¾“å‡º $${meta.price.output}/1M tokens`;
  } else {
    descEl.textContent = modelId ? 'è¯¥æ¨¡å‹æ— è¯¦ç»†è¯´æ˜ã€‚' : 'è¯·é€‰æ‹©æ¨¡å‹ã€‚';
  }
}

// ========== è·å–æ¨¡å‹åˆ—è¡¨ï¼ˆä½¿ç”¨åŠ¨æ€ Base URLï¼‰==========
async function fetchModels(apiKey, baseUrl) {
  const modelSelect = document.getElementById('modelSelect');
  const modelDesc = document.getElementById('modelDesc');
  modelSelect.disabled = true;
  modelSelect.innerHTML = '<option value="">åŠ è½½ä¸­...</option>';
  modelDesc.textContent = 'æ­£åœ¨è¯·æ±‚æ¨¡å‹åˆ—è¡¨...';

  try {
    const url = getFullUrl('/v1/models');
    const res = await fetch(url, { headers: { 'Authorization': `Bearer ${apiKey}` } });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    const models = data.data || [];

    modelSelect.innerHTML = '<option value="">â€” è‡ªå®šä¹‰æ¨¡å‹ ID â€”</option>';
    models.sort((a, b) => a.id.localeCompare(b.id)).forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.id;
      opt.textContent = m.id;
      modelSelect.appendChild(opt);
    });

    modelSelect.disabled = false;
    modelDesc.textContent = 'è¯·é€‰æ‹©æ¨¡å‹ã€‚';
    if (settings.model && models.some(m => m.id === settings.model)) {
      modelSelect.value = settings.model;
      updateModelDescription(settings.model);
    }
  } catch (error) {
    modelSelect.innerHTML = '<option value="">åŠ è½½å¤±è´¥</option>';
    modelDesc.textContent = 'âŒ æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ API Key æˆ– Base URLã€‚';
    modelSelect.disabled = false;
  }
}

// ========== ä¿å­˜ Base URL ==========
function validateAndSaveBaseUrl() {
  const input = document.getElementById('apiBaseUrl');
  let url = input.value.trim();
  const statusEl = document.getElementById('baseUrlStatus');

  if (!url) {
    url = 'https://api.gemai.cc';
    input.value = url;
  }

  try {
    new URL(url); // éªŒè¯æ˜¯å¦ä¸ºåˆæ³• URL
    if (!url.startsWith('http')) throw new Error('å¿…é¡»ä»¥ http/https å¼€å¤´');
  } catch (e) {
    statusEl.textContent = 'âš ï¸ è¯·è¾“å…¥æœ‰æ•ˆçš„ URLï¼ˆå¦‚ https://your-proxy.comï¼‰';
    statusEl.style.color = '#d9534f';
    return false;
  }

  settings.apiBaseUrl = url;
  localStorage.setItem('agentSettings', JSON.stringify(settings));
  statusEl.textContent = `âœ… å·²è®¾ç½®ä¸ºï¼š${url}`;
  statusEl.style.color = '';
  return true;
}

// ========== åˆå§‹åŒ–è®¾ç½® ==========
function loadSettings() {
  const saved = localStorage.getItem('agentSettings');
  if (saved) {
    const parsed = JSON.parse(saved);
    settings = { ...settings, ...parsed };
    document.getElementById('apiKey').value = settings.apiKey || '';
    document.getElementById('apiBaseUrl').value = settings.apiBaseUrl || 'https://api.gemai.cc';

    if (settings.apiBaseUrl) {
      document.getElementById('baseUrlStatus').textContent = `å½“å‰ä½¿ç”¨ï¼š${settings.apiBaseUrl}`;
    }
  }
}

function enableChat() {
  document.getElementById('messageInput').disabled = false;
  document.getElementById('sendBtn').disabled = false;
}

// ========== æ¶ˆæ¯ç³»ç»Ÿï¼ˆä½¿ç”¨åŠ¨æ€ Base URLï¼‰==========(APIè¯·æ±‚å¤´)
function addMessage(text, sender, isStreaming = false) {
  let messageDiv;
  if (isStreaming) {
    const lastAi = document.querySelector('.message.ai-message.streaming');
    if (lastAi) {
      lastAi.textContent += text;
      return;
    }
    messageDiv = document.createElement('div');
    messageDiv.className = 'message ai-message streaming';
    messageDiv.textContent = text;
  } else {
    messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    messageDiv.innerHTML = sender === 'ai' ? text.replace(/\n/g, '<br>') : text;
  }
  document.getElementById('chatMessages').appendChild(messageDiv);
  document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
}

async function sendMessageToAPI(message) {
  const model = settings.model || 'gpt-4o-mini';
  const url = getFullUrl('/v1/chat/completions');

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${settings.apiKey}`
    },
    body: JSON.stringify({
      model,
      messages: [{ role: 'user', content: message }],
      stream: true,
      temperature: 0.7
    })
  });

  if (!response.ok) {
    const errText = await response.text();
    throw new Error(`HTTP ${response.status}: ${errText}`);
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let fullResponse = '';
  let usage = { prompt_tokens: 0, completion_tokens: 0 };

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split('\n').filter(line => line.trim().startsWith('data: '));
      for (const line of lines) {
        const data = line.substring(6).trim();
        if (data === '[DONE]') continue;
        try {
          const json = JSON.parse(data);
          if (json.usage) usage = json.usage;
          const content = json.choices?.[0]?.delta?.content || '';
          if (content) {
            fullResponse += content;
            addMessage(content, 'ai', true);
          }
        } catch (e) { /* ignore */ }
      }
    }
  } finally {
    reader.releaseLock();
  }

  const lastStreaming = document.querySelector('.message.ai-message.streaming');
  if (lastStreaming) lastStreaming.classList.remove('streaming');

  const inTokens = usage.prompt_tokens || 0;
  const outTokens = usage.completion_tokens || Math.ceil(fullResponse.length / 4);
  totalInputTokens += inTokens;
  totalOutputTokens += outTokens;
  updateCostDisplay(model, inTokens, outTokens);
}
//========== æ¶ˆè€—è®¡ç®— ==========
function updateCostDisplay(model, inTokens, outTokens) {
  const costData = document.getElementById('costData');
  let totalCost = 0;
  if (MODEL_METADATA[model]) {
    const p = MODEL_METADATA[model].price;
    totalCost = (inTokens * p.input + outTokens * p.output) / 1e6;
  }
  const totalEstimated = ((totalInputTokens * (MODEL_METADATA[model]?.price.input || 0) +
                          totalOutputTokens * (MODEL_METADATA[model]?.price.output || 0)) / 1e6);
  costData.innerHTML = `
    è¾“å…¥: ${totalInputTokens} tokens<br>
    è¾“å‡º: ${totalOutputTokens} tokens<br>
    æœ¬æ¬¡: ~$${totalCost.toFixed(5)}<br>
    æ€»è®¡: ~$${totalEstimated.toFixed(5)}
  `;
}

// ========== äº‹ä»¶ç»‘å®š ==========
document.addEventListener('DOMContentLoaded', () => {
  // ä¿å­˜ Base URL
  document.getElementById('saveBaseUrl').addEventListener('click', () => {
    if (validateAndSaveBaseUrl()) {
      addMessage(`ğŸŒ API åŸºç¡€ URL å·²æ›´æ–°ä¸ºï¼š${settings.apiBaseUrl}`, 'ai');
    }
  });

  // ä¿å­˜ API Key
  document.getElementById('saveSettings').addEventListener('click', () => {
    const key = document.getElementById('apiKey').value.trim();
    if (!key) return alert('è¯·è¾“å…¥ API å¯†é’¥ï¼');
    settings.apiKey = key;
    localStorage.setItem('agentSettings', JSON.stringify(settings));
    fetchModels(key, settings.apiBaseUrl);
    enableChat();
    addMessage('âœ… è®¾ç½®å·²ä¿å­˜ï¼Œæ¨¡å‹åˆ—è¡¨å·²æ›´æ–°ï¼', 'ai');
  });

  // å‘é€æ¶ˆæ¯
  document.getElementById('sendBtn').addEventListener('click', async () => {
    const input = document.getElementById('messageInput');
    const msg = input.value.trim();
    if (!msg) return;
    addMessage(msg, 'user');
    input.value = '';
    try {
      await sendMessageToAPI(msg);
    } catch (err) {
      addMessage(`âŒ é”™è¯¯ï¼š${err.message}`, 'ai');
    }
  });

  // å›è½¦å‘é€
  document.getElementById('messageInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      document.getElementById('sendBtn').click();
    }
  });

  // æ¨¡å‹é€‰æ‹©
  document.getElementById('modelSelect').addEventListener('change', (e) => {
    settings.model = e.target.value;
    localStorage.setItem('agentSettings', JSON.stringify(settings));
    updateModelDescription(settings.model);
  });

  // åŸå¸‚å¤©æ°”
  const cityInput = document.getElementById('cityInput');
  let debounceTimer;
  cityInput.addEventListener('input', (e) => {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      const city = e.target.value.trim();
      if (city) {
        fetchWeather(city);
        localStorage.setItem('preferredCity', city);
      }
    }, 500);
  });

  // åˆå§‹åŒ–
  loadSettings();
  const savedCity = localStorage.getItem('preferredCity') || 'æ¸©å·';
  cityInput.value = savedCity;
  fetchWeather(savedCity);

  updateTime();
  setInterval(updateTime, 1000);
});